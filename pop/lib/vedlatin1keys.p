/* --- Copyright University of Sussex 1992. All rights reserved. ----------
 > File:            $poplocal/local/lib/vedlatin1keys.p
 > Purpose:         Key-press sequences for ISO Latin-1 characters in VED
 > Author:          Richard Dallaway, Dec 10 1992
 > Documentation:   HELP * VEDLATIN1KEYS
 > Related Files:   HELP * VED_IC
 */


compile_mode:pop11 +defcon +defpdr;

section;

/* A key-press sequence (e.g., ESC-A) calls -latin1_read_and_insert-,
   which reads another keyboard sequence.  The sequence of keys are used
   to lookup an ISO Latin-1 character, which is then inserted into the
   current VED buffer.

   The "latin1_table" contains the conversion from key presses to ascii codes.

   Some latin1 characters can be generated by a single key (after the ESC-A),
   like ESC-A c for a "ç".  In the "latin1_table" list such entries are of
   the form:

    [<string> [just <ascii>] ]

    e.g.,

    ['c'    [just 231] ] for the "ç".


    Other sequences are longer.  For example, "â" is generated by ESC-A ^ a.
    In the list, these entries are of the form:

    [<string> [<word> <number> <word2> <number2> ... ]   ]


    The <string> corresponds to the first keypress (e.g., "^" in the example).
    The <word> corresponds to the next keypress (a), and <number> is the
    appropriate Latin-1 code.

*/

vars latin1_table = [

    ['^'    [A 194 E 202 I 206 O 212 U 219 a 226 e 234 i 238 o 244 u 251] ]

    ['\`'   [A 192 E 200 I 204 O 210 U 217 a 224 e 232 i 236 o 242 u 249] ]

    ['\''   [A 193 E 201 I 205 O 211 U 218 Y 221
             a 225 e 233 i 237 o 243 u 250 y 253 n 180] ]

    ['~'    [A 195 N 209 O 213 a 227 n 241 o 245]]

    ['\"'   [n 168 A 196 E 203 I 207 O 214 U 220 a 228 e 235
            i 239 o 246 u 252 y 255] ]


    ['a' [just 229]]    ;;; å
    ['A' [just 197]]    ;;; Å

    ['c' [just 231]]    ;;; ç
    ['C' [just 199]]    ;;; Ç
    ['k' [just 184]]    ;;; ¸

    ['e' [just 230]]    ;;; æ
    ['E' [just 198]]    ;;; Æ

    ['x' [just 215]]    ;;; ×
    ['/' [just 247]]    ;;; ÷

    ['D' [just 208]]    ;;; Ð
    ['B' [just 223]]    ;;; ß

    ['O' [just 216]]    ;;; Ø
    ['o' [just 248]]    ;;; ø

    ['T' [just 222]]    ;;; Þ
    ['t' [just 254]]    ;;; þ

    ['!' [just 161]]    ;;; ¡
    ['?' [just 191]]    ;;; ¿

    ['|' [just 166]]    ;;; ¦
    ['-' [just 175]]    ;;; ¯
    ['_' [just 173]]    ;;; ­
    ['\\' [just 172]]   ;;; ¬

    ['>' [just 187]]    ;;; »
    ['<' [just 171]]    ;;; «

    ['1' [just 185]]    ;;; ¹
    ['2' [just 178]]    ;;; ²
    ['3' [just 179]]    ;;; ³
    ['0' [just 176]]    ;;; °

    ['.' [just 183]]    ;;; ·

    ['u' [a 170 o 186]] ;;; ª º

    ['s' [c 169 r 174 s 167 p 182 ]]    ;;; © ® § ¶
    ['f' [q 188 h 189 t 190]]           ;;; ¼ ½ ¾

    ['m' [c 164 s 162 p 163 y 165]]     ;;; ¤ ¢ £ ¥

    ['h' [just 240] ]   ;;; ð


];

define latin1_character(IndexString, SpecificWord) -> String;
    ;;; Returns a Latin-1 String or <false>

    lvars String = inits(1);
    vars Code;

    ;;; We really do need a word here
    if isstring(SpecificWord) then
        consword(SpecificWord) -> SpecificWord;
    endif;

    if latin1_table matches [== [^IndexString [== ^SpecificWord ?Code ==]]==]
    then
        Code -> String(1);
    elseif latin1_table matches [== [^IndexString [just ?Code]] ==] then
        Code -> String(1);
    else
        false -> String;
    endif;

enddefine;


define latin1_read_and_insert;
    ;;; Scans keyboard for one or two key presses and inserts and appropriate
    ;;; Latin-1 character into the VED buffer.

    vars conversions, number;
    lvars char=inits(1), word;

    define dlocal pop_timeout;
        if iscaller(vedinascii) then
            exitfrom(false, vedinascii);
        endif;
    enddefine;

    ;;; Read the first key press
    vedclearinput();
    vedinascii() -> char(1);

    ;;; Check to see if know that category
    if latin1_table matches [== [^char ?conversions] ==] then
        ;;; ok
    else
        vederror('Don\'t recognize that character; try ^ \' \" \` ~ etc');
    endif;

    ;;; Single key codes
    if conversions matches [just ?number] then
        number -> char(1);
        vedinsertstring(char);
        return;
    endif;

    ;;; Read next key press
    vedclearinput();
    vedinascii() -> char(1);

    consword(char) -> word;

    ;;; Look up the conversion
    if conversions matches [== ^word ?number ==] then
        number -> char(1);
        vedinsertstring(char);
    else
        vederror('No conversion for that character.');
    endif;

enddefine;

;;; ATTATCH PROCEDURE TO KEYBOARD

vars vedlatin1key;

;;; Don't assign a keyboard sequence for -latin1_read_and_insert- if the
;;; uses sets "vedlatin1key" to <false>

unless vedlatin1key = false then
    unless isstring(vedlatin1key) then
        ;;; Default assignment -- Esc a (a for accent?)
        '\^[a' -> vedlatin1key;
    endunless;
    vedsetkey(vedlatin1key, latin1_read_and_insert);
endunless;

endsection;
